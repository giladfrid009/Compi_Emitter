%{

#include "hw3_output.hpp"
#include "symbol_table.hpp"
#include "generic_syntax.hpp" 
#include "code_buffer.hpp"
#include "types.hpp"
#include <list>
#include <string>
#include <iostream>
#include <sstream>

using std::vector;
using std::string;
using std::stringstream;

extern int yylineno;

extern int yylex();

static symbol_table& symtab = symbol_table::instance();
static code_buffer& codebuf = code_buffer::instance();

void yyerror(const char* message);

void add_builtin_functions();

void create_function_header(type_syntax* return_type, syntax_token* indentifier_token, list_syntax<parameter_syntax>* parameters);

void emit_function_finish(function_declaration_syntax* function);

expression_syntax* validate_bool_expression(expression_syntax* expression);

void print_current_scope();

%}

%code requires 
{
    #include "syntax_token.hpp"
    #include "abstract_syntax.hpp" 
    #include "generic_syntax.hpp" 
    #include "expression_syntax.hpp"
    #include "statement_syntax.hpp" 
}

%union 
{                                    
    syntax_token*                             token;
    root_syntax*                              root;
    type_syntax*                              type;  
    jump_syntax*                              jump;
    label_syntax*                             label;
    parameter_syntax*                         param;     
    function_declaration_syntax*              function;            
    statement_syntax*                         statement; 	
    expression_syntax*                        expression;  
    list_syntax<parameter_syntax>*            param_list;		         
    list_syntax<function_declaration_syntax>* function_list;	
    list_syntax<statement_syntax>*            statement_list;
    list_syntax<expression_syntax>*           expression_list;                
 };

%token END 0
%token <token> VOID
%token <token> INT
%token <token> BYTE
%token <token> B
%token <token> BOOL
%token <token> TRUE
%token <token> FALSE
%token <token> RETURN
%token <token> WHILE
%token <token> BREAK
%token <token> CONTINUE
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token <token> NUM
%token <token> ID
%token <token> STRING

%right LPAREN
%left RPAREN
%right <token> ASSIGN
%nonassoc <token> IF
%nonassoc <token> ELSE
%left <token> OR
%left <token> AND
%left <token> EQOP
%left <token> RELOP
%left <token> ADDOP
%left <token> MULOP
%right <token> NOT

%type <root>            Program
%type <function_list>   Funcs
%type <function>        FuncDecl
%type <type>            RetType
%type <param_list> 	    Params
%type <param_list>      ParamsList
%type <param>           ParamDecl
%type <statement_list>  Statements
%type <statement>   	Statement
%type <expression>      Call
%type <expression_list> ExpList
%type <type>			Type
%type <expression>      Exp
%type <expression>      BoolExp
%type <jump>            J
%type <label>           L

%%

Program 	: Funcs END										        { $$ = new root_syntax($1); delete $$; }
			;       
Funcs   	: %empty                                                { $$ = new list_syntax<function_declaration_syntax>(); }
      		| FuncDecl Funcs					                    { $$ = $2->push_front($1); }
			;
FuncDecl 	: RetType ID LPAREN Params RPAREN                       { create_function_header($1, $2, $4); } 
              LBRACE Statements CS RBRACE                           { $$ = new function_declaration_syntax($1, $2, $4, $8); emit_function_finish($$); }
			;
RetType 	: Type                                                  { $$ = $1; }
        	| VOID                                                  { $$ = new type_syntax($1); }
			;       
Params 	    : %empty                                                { $$ = new list_syntax<parameter_syntax>(); }
        	| ParamsList                                            { $$ = $1; }
			;       
ParamsList  : ParamDecl                                             { $$ = new list_syntax<parameter_syntax>($1); }
			| ParamDecl COMMA ParamsList                            { $$ = $3->push_front($1); }
			;       
ParamDecl 	: Type ID                                               { $$ = new parameter_syntax($1, $2); }
			;       
Statements	: Statement	                                            { $$ = new list_syntax<statement_syntax>($1); }
 			| Statements Statement                                  { $$ = $1->push_back($2); }
			;
Statement	: LBRACE OS Statements CS RBRACE                        { $$ = new block_statement($3); }
			| Type ID SC                                            { $$ = new declaration_statement($1, $2); }
			| Type ID ASSIGN Exp SC                                 { $$ = new declaration_statement($1, $2, $3, $4); }
			| ID ASSIGN Exp SC                                      { $$ = new assignment_statement($1, $2, $3); }
			| Call SC                                               { $$ = new expression_statement($1); }
			| RETURN SC	                                            { $$ = new return_statement($1); }
			| RETURN Exp SC                                         { $$ = new return_statement($1, $2); }
			| IF LPAREN BoolExp RPAREN OS L Statement CS L          { 
                                                                        $$ = new if_statement($1, $3, $7); 

                                                                        $$->break_list = $7->break_list;
                                                                        $$->continue_list = $7->continue_list;
                                                                        codebuf.backpatch($3->jump_list, $3->jump_label);
                                                                        codebuf.backpatch($3->true_list, $6->label); 
                                                                        codebuf.backpatch($3->false_list, $9->label);

                                                                        codebuf.new_line();

                                                                        delete $6; delete $9;
                                                                    }
			| IF LPAREN BoolExp RPAREN OS L Statement CS L
              ELSE J OS L Statement CS L                             { 
                                                                        $$ = new if_statement($1, $3, $7, $10, $14); 

                                                                        $$->break_list = codebuf.merge($7->break_list, $14->break_list);
                                                                        $$->continue_list = codebuf.merge($7->continue_list, $14->continue_list);
                                                                        codebuf.backpatch($3->jump_list, $3->jump_label);
                                                                        codebuf.backpatch($3->true_list, $6->label); 
                                                                        codebuf.backpatch($3->false_list, $13->label);
                                                                        codebuf.backpatch($11->jump_list, $16->label);

                                                                        codebuf.new_line();

                                                                        delete $6; delete $9; delete $11; delete $13; delete $16;
                                                                    }
			| WHILE LPAREN BoolExp RPAREN OSL L Statement J CS L    { 
                                                                        $$ = new while_statement($1, $3, $7); 

                                                                        codebuf.backpatch($3->jump_list, $3->jump_label);
                                                                        codebuf.backpatch($3->true_list, $6->label); 
                                                                        codebuf.backpatch($3->false_list, $10->label);
                                                                        codebuf.backpatch($7->continue_list, $3->jump_label);
                                                                        codebuf.backpatch($7->break_list, $10->label);
                                                                        codebuf.backpatch($8->jump_list, $3->jump_label);

                                                                        codebuf.new_line();

                                                                        delete $6; delete $8; delete $10;
                                                                    }
			| BREAK SC                                              { $$ = new branch_statement($1); }
			| CONTINUE SC                                           { $$ = new branch_statement($1); }
            ;       
Call 		: ID LPAREN ExpList RPAREN                              { $$ = new invocation_expression($1, $3); }
 			| ID LPAREN RPAREN                                      { $$ = new invocation_expression($1); }
			;       
ExpList 	: Exp                                                   { $$ = new list_syntax<expression_syntax>($1); }
 			| Exp COMMA ExpList                                     { $$ = $3->push_front($1); }
			;       
Type 		: INT                                                   { $$ = new type_syntax($1); }
			| BYTE                                                  { $$ = new type_syntax($1); }
			| BOOL                                                  { $$ = new type_syntax($1); }
			;       
Exp 		: LPAREN Exp RPAREN	                                    { $$ = $2; }
            | Exp IF LPAREN Exp RPAREN ELSE Exp                     { $$ = new conditional_expression($1, $2, $4, $6, $7); }
			| Exp ADDOP Exp                                         { $$ = new arithmetic_expression($1, $2, $3); }
            | Exp MULOP Exp                                         { $$ = new arithmetic_expression($1, $2, $3); }
			| ID                                                    { $$ = new identifier_expression($1); }
			| Call                                                  { $$ = $1; }
			| NUM                                                   { $$ = new literal_expression<int>($1); }
			| NUM B                                                 { $$ = new literal_expression<unsigned char>($1); delete $2; }
			| STRING                                                { $$ = new literal_expression<string>($1); }
			| TRUE                                                  { $$ = new literal_expression<bool>($1); }
			| FALSE                                                 { $$ = new literal_expression<bool>($1); }
			| NOT Exp                                               { $$ = new not_expression($1, $2); }
			| Exp AND Exp                                           { $$ = new logical_expression($1, $2, $3); }
			| Exp OR Exp                                            { $$ = new logical_expression($1, $2, $3); }
			| Exp RELOP Exp                                         { $$ = new relational_expression($1, $2, $3); }
            | Exp EQOP Exp                                          { $$ = new relational_expression($1, $2, $3); } 
			| LPAREN Type RPAREN Exp %prec NOT                      { $$ = new cast_expression($2, $4); }
			;
BoolExp     : Exp                                                   { $$ = validate_bool_expression($1); }
            ;
OS          : %empty                                                { symtab.open_scope(); codebuf.increase_indent(); } 
            ;
OSL         : %empty                                                { symtab.open_scope(true); codebuf.increase_indent(); }
            ;
CS          : %empty                                                { symtab.close_scope(); codebuf.decrease_indent(); }
            ;
J           : %empty                                                { $$ = new jump_syntax(); }
            ;
L           : %empty                                                { $$ = new label_syntax(); }
            ;
%%

int main()
{
    symtab.open_scope();
    
    add_builtin_functions();

	int res = yyparse();

    codebuf.print_globals();
    codebuf.print();

    return res;
}

void yyerror(const char* message)
{
    output::error_syn(yylineno);
}

void add_builtin_functions()
{
    symtab.add_function("print", type_kind::Void, vector<type_kind>{type_kind::String});
    symtab.add_function("printi", type_kind::Void, vector<type_kind>{type_kind::Int});

    codebuf.emit_from_file("builtin_functions.llvm");
}

void create_function_header(type_syntax* return_type, syntax_token* indentifier_token, list_syntax<parameter_syntax>* parameters)
{
    string func_name = indentifier_token->text;

    if (symtab.contains_symbol(func_name))
    {
        output::error_def(indentifier_token->position, func_name);
    }

    vector<type_kind> param_types;

    for (auto param : *parameters)
    {
        param_types.push_back(param->type->kind);
    }

    symtab.add_function(func_name, return_type->kind, param_types);

    symtab.open_scope();

    for (auto param : *parameters)
    {
        if (symtab.contains_symbol(param->identifier))
        {
            output::error_def(param->identifier_token->position, param->identifier);
        }

        symtab.add_parameter(param->identifier, param->type->kind);
    }

    stringstream instr;

    string ret_type = ir_builder::get_type(return_type->kind);

    instr << ir_builder::format_string("define %s @%s (", ret_type, func_name);

    for (auto param = parameters->begin(); param != parameters->end(); param++)
    {
        instr << ir_builder::get_type((*param)->type->kind);

        if (std::distance(param, parameters->end()) > 1)
        {
            instr << " , ";
        }
    }

    instr << ") {";

    codebuf.emit(instr.str());

    codebuf.increase_indent();
}

void emit_function_finish(function_declaration_syntax* function)
{
    codebuf.increase_indent();

    if (function->identifier == "main")
    {
        codebuf.emit("call void @exit(i32 0)");
    }
    
    if (function->return_type->kind == type_kind::Void)
    {
        codebuf.emit("ret void");
    }
    else
    {
        codebuf.emit("ret i32 0");
    }

    codebuf.decrease_indent();

    codebuf.emit("}\n");
}

expression_syntax* validate_bool_expression(expression_syntax* expression)
{
    if (expression->return_type != type_kind::Bool)
    {
        output::error_mismatch(yylineno);
    }

    return expression;
}

void print_current_scope()
{
    output::end_scope();

    for (auto sym : symbol_table::instance().current_scope().get_symbols())
    {
        std::cout << sym->to_string() << std::endl;
    }
}
